{% extends "base.html" %}

{% block title %}YouTube Learning Library{% endblock %}

{% block content %}
<!-- Dual Search Interface -->
<div class="dual-search">
    <!-- Left: Traditional Search -->
    <div class="search-panel">
        <h3 class="panel-title">Keyword Search</h3>
        <div class="search-container">
            <input type="text" id="search-input" placeholder="Search videos, transcripts...">
            <button id="search-btn">Search</button>
            <button id="clear-search" style="display: none;">Clear</button>
        </div>
        <p class="search-explainer">Matches any keyword across titles, summaries, and transcripts. Use specific terms for better results.</p>
        <div id="search-results" class="search-results" style="display: none;"></div>
    </div>

    <!-- Right: AI Chat Assistant -->
    <div class="chat-panel">
        <h3 class="panel-title">AI Assistant</h3>
        <div class="chat-container">
            <div id="chat-messages" class="chat-messages">
                <div class="chat-message assistant">
                    <p>Ask me anything. I'll find and recommend the most relevant videos from the library.</p>
                </div>
            </div>
            <div class="chat-input-container">
                <input type="text" id="chat-input" placeholder="e.g., How do I learn about Kubernetes security?">
                <button id="chat-btn">Ask</button>
            </div>
        </div>
    </div>
</div>

<!-- Search History Panel -->
<div class="history-panel">
    <div class="history-header">
        <h3 class="panel-title">Search History</h3>
        <div class="history-controls">
            <button id="toggle-history" class="history-toggle">Show</button>
            <button id="clear-history" class="history-clear">Clear All</button>
        </div>
    </div>
    <div id="history-content" class="history-content" style="display: none;">
        <div id="history-list" class="history-list"></div>
    </div>
</div>

<!-- Library Content -->
<div id="library-content">
<div class="filters">
    <div class="filter-group">
        <h3>Topics</h3>
        <div class="tags">
            {% for topic in topics %}
            <a href="topics/{{ topic }}.html" class="tag">{{ topic }}</a>
            {% endfor %}
        </div>
    </div>

    <div class="filter-group">
        <h3>Format</h3>
        <div class="tags">
            {% for fmt in formats %}
            <a href="#" class="tag" data-filter="format" data-value="{{ fmt }}">{{ fmt }}</a>
            {% endfor %}
        </div>
    </div>

    <div class="filter-group">
        <h3>Difficulty</h3>
        <div class="tags">
            {% for diff in difficulties %}
            <a href="#" class="tag" data-filter="difficulty" data-value="{{ diff }}">{{ diff }}</a>
            {% endfor %}
        </div>
    </div>

    {% if channels %}
    <div class="filter-group">
        <h3>Channels</h3>
        <div class="tags">
            {% for channel in channels %}
            <a href="channels/{{ channel.slug }}.html" class="tag">{{ channel.name }}</a>
            {% endfor %}
            {% if channels|length >= 10 %}
            <a href="channels/index.html" class="tag" style="background: var(--accent);">All channels...</a>
            {% endif %}
        </div>
    </div>
    {% endif %}
</div>

<div class="entries">
    {% for entry in entries %}
    <article class="entry-card {% if entry.content_type == 'paper' %}paper-card{% endif %}"
             data-topics="{{ entry.facets.topics|join(',') }}"
             data-format="{{ entry.facets.format }}"
             data-difficulty="{{ entry.facets.difficulty }}"
             data-type="{{ entry.content_type|default('video') }}">
        {% if entry.content_type == 'paper' %}
        <span class="content-type-badge paper-badge">Paper</span>
        <h2><a href="papers/{{ entry._filename }}.html">{{ entry.title }}</a></h2>
        {% else %}
        <h2><a href="transcripts/{{ entry._filename }}.html">{{ entry.title }}</a></h2>
        {% endif %}
        <div class="entry-meta">
            {% if entry.duration_seconds %}
            <span class="duration">{{ entry.duration_seconds|format_duration }}</span>
            •
            {% endif %}
            {% if entry.upvotes %}
            <span class="upvotes">▲ {{ entry.upvotes }}</span>
            •
            {% endif %}
            <span class="topic">{{ entry.facets.topics|join(', ') }}</span>
            •
            <span class="difficulty">{{ entry.facets.difficulty }}</span>
            •
            <span class="date">{{ entry.added_date }}</span>
        </div>
        {% if entry.summary %}
        <div class="entry-summary">
            <ul>
                {% for point in entry.summary[:3] %}
                <li>{{ point }}</li>
                {% endfor %}
            </ul>
        </div>
        {% endif %}
    </article>
    {% endfor %}
</div>

</div><!-- End library-content -->

<script>
// Simple client-side filtering
document.querySelectorAll('.tag[data-filter]').forEach(tag => {
    tag.addEventListener('click', (e) => {
        e.preventDefault();
        const filter = tag.dataset.filter;
        const value = tag.dataset.value;

        // Toggle active state
        tag.classList.toggle('active');

        // Get all active filters
        const activeFilters = {};
        document.querySelectorAll('.tag.active[data-filter]').forEach(t => {
            const f = t.dataset.filter;
            if (!activeFilters[f]) activeFilters[f] = [];
            activeFilters[f].push(t.dataset.value);
        });

        // Filter entries
        document.querySelectorAll('.entry-card').forEach(card => {
            let show = true;

            for (const [filterName, values] of Object.entries(activeFilters)) {
                const cardValue = card.dataset[filterName];
                if (!values.some(v => cardValue.includes(v))) {
                    show = false;
                    break;
                }
            }

            card.style.display = show ? 'block' : 'none';
        });
    });
});

// Search functionality (client-side with library.json fallback)
const searchInput = document.getElementById('search-input');
const searchBtn = document.getElementById('search-btn');
const clearBtn = document.getElementById('clear-search');
const searchResults = document.getElementById('search-results');
const libraryContent = document.getElementById('library-content');

// Configuration
const CONFIG = {
    // Worker API URL - handles /api/* routes with API key hidden
    API_URL: 'https://youtube-library-api.dlkarpay.workers.dev'
};

let libraryData = null;  // Cached library data for client-side search

function formatDuration(seconds) {
    if (!seconds) return '0m';
    if (seconds < 60) return `${seconds}s`;
    if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    return `${h}h ${m}m`;
}

// Client-side search using library.json
async function loadLibraryData() {
    if (libraryData) return libraryData;
    try {
        const response = await fetch('/library.json');
        libraryData = await response.json();
        return libraryData;
    } catch (err) {
        console.error('Failed to load library.json:', err);
        return null;
    }
}

function clientSideSearch(query, entries) {
    const terms = query.toLowerCase().split(/\s+/).filter(t => t.length > 1);
    if (terms.length === 0) return [];

    const scored = entries.map(entry => {
        let score = 0;
        const title = (entry.title || '').toLowerCase();
        const summary = (entry.summary || []).join(' ').toLowerCase();
        const topics = (entry.facets?.topics || []).join(' ').toLowerCase();

        for (const term of terms) {
            // Title matches worth more
            if (title.includes(term)) score += 10;
            // Summary matches
            if (summary.includes(term)) score += 5;
            // Topic matches
            if (topics.includes(term)) score += 3;
        }

        return { entry, score };
    });

    return scored
        .filter(s => s.score > 0)
        .sort((a, b) => b.score - a.score)
        .slice(0, 20)
        .map(s => s.entry);
}

async function performSearch() {
    const query = searchInput.value.trim();
    if (!query) return;

    searchResults.innerHTML = '<p style="color: var(--text-muted);">Searching...</p>';
    searchResults.style.display = 'block';
    libraryContent.style.display = 'none';
    clearBtn.style.display = 'inline-block';

    // Try server-side search first, fall back to client-side
    try {
        const response = await fetch(`/api/search?q=${encodeURIComponent(query)}&limit=20`);
        if (!response.ok) throw new Error('Server not available');
        const data = await response.json();

        if (data.error) throw new Error(data.error);

        if (data.results.length === 0) {
            searchResults.innerHTML = '<p style="color: var(--text-muted);">No results found. Try different keywords.</p>';
            return;
        }

        searchResults.innerHTML = `
            <p style="color: var(--text-muted); margin-bottom: 1rem;">
                Found ${data.total} result${data.total !== 1 ? 's' : ''} for "${data.query}"
            </p>
            ${data.results.map(r => `
                <article class="search-result-card">
                    <h2><a href="transcripts/${r.slug}.html">${r.title_highlighted || r.title}</a></h2>
                    <div class="entry-meta">
                        <span class="duration">${r.duration || formatDuration(r.duration_seconds)}</span>
                        ${r.channel && r.channel.name ? `• <a href="channels/${r.channel.slug}.html" class="channel-link">${r.channel.name}</a>` : ''}
                        • <span class="topic">${(r.facets.topics || []).join(', ')}</span>
                        • <span class="difficulty">${r.facets.difficulty || ''}</span>
                    </div>
                    ${r.matching_sections && r.matching_sections.length > 0 ? `
                        <div class="matching-sections">
                            <strong style="color: var(--text-muted); font-size: 0.85rem;">Matching sections:</strong>
                            ${r.matching_sections.map(s => `
                                <div class="matching-section">
                                    <a href="${s.timestamp_url}" target="_blank">
                                        <span class="timestamp">${s.timestamp}</span>
                                        ${s.title}
                                    </a>
                                    <p>${s.description}</p>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                </article>
            `).join('')}
        `;
    } catch (err) {
        // Fall back to client-side search
        console.log('Using client-side search');
        const data = await loadLibraryData();
        if (!data || !data.entries) {
            searchResults.innerHTML = '<p style="color: var(--text-muted);">Could not load library data.</p>';
            return;
        }

        const results = clientSideSearch(query, data.entries);

        if (results.length === 0) {
            searchResults.innerHTML = '<p style="color: var(--text-muted);">No results found. Try different keywords.</p>';
            return;
        }

        searchResults.innerHTML = `
            <p style="color: var(--text-muted); margin-bottom: 1rem;">
                Found ${results.length} result${results.length !== 1 ? 's' : ''} for "${query}"
            </p>
            ${results.map(r => `
                <article class="search-result-card">
                    <h2><a href="transcripts/${r._filename}.html">${r.title}</a></h2>
                    <div class="entry-meta">
                        <span class="duration">${formatDuration(r.duration_seconds)}</span>
                        ${r.channel && r.channel.name ? `• <a href="channels/${r.channel.slug}.html" class="channel-link">${r.channel.name}</a>` : ''}
                        • <span class="topic">${(r.facets?.topics || []).join(', ')}</span>
                        • <span class="difficulty">${r.facets?.difficulty || ''}</span>
                    </div>
                    ${r.summary && r.summary.length > 0 ? `
                        <div class="entry-summary">
                            <ul>${r.summary.slice(0, 2).map(s => `<li>${s}</li>`).join('')}</ul>
                        </div>
                    ` : ''}
                </article>
            `).join('')}
        `;
    }
}

function clearSearch() {
    searchInput.value = '';
    searchResults.style.display = 'none';
    searchResults.innerHTML = '';
    libraryContent.style.display = 'block';
    clearBtn.style.display = 'none';
}

searchBtn.addEventListener('click', performSearch);
searchInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') performSearch();
});
clearBtn.addEventListener('click', clearSearch);

// AI Chat functionality
const chatInput = document.getElementById('chat-input');
const chatBtn = document.getElementById('chat-btn');
const chatMessages = document.getElementById('chat-messages');

function addChatMessage(content, role) {
    const msgDiv = document.createElement('div');
    msgDiv.className = `chat-message ${role}`;
    msgDiv.innerHTML = `<p>${content}</p>`;
    chatMessages.appendChild(msgDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

function formatChatResponse(data) {
    const response = data.response || '';

    // Convert markdown to HTML
    let html = response
        // Escape HTML first
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        // Headers
        .replace(/^### (.+)$/gm, '<h4>$1</h4>')
        .replace(/^## (.+)$/gm, '<h3>$1</h3>')
        // Bold and italic
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
        .replace(/\*([^*]+)\*/g, '<em>$1</em>')
        // Timestamps like [00:05:05]
        .replace(/\[(\d{2}:\d{2}:\d{2})\]/g, '<span class="timestamp">$1</span>')
        // Convert markdown tables to HTML
        .replace(/\|(.+)\|\n\|[-:\s|]+\|\n((?:\|.+\|\n?)+)/g, (match, header, rows) => {
            const headers = header.split('|').map(h => h.trim()).filter(h => h);
            const rowData = rows.trim().split('\n').map(row =>
                row.split('|').map(c => c.trim()).filter(c => c)
            );
            let table = '<table class="chat-table"><thead><tr>';
            headers.forEach(h => table += `<th>${h}</th>`);
            table += '</tr></thead><tbody>';
            rowData.forEach(row => {
                table += '<tr>';
                row.forEach(cell => table += `<td>${cell}</td>`);
                table += '</tr>';
            });
            table += '</tbody></table>';
            return table;
        });

    // Convert bullet lists (lines starting with -)
    const lines = html.split('\n');
    let inList = false;
    let result = [];

    for (let line of lines) {
        const isBullet = /^- (.+)$/.test(line.trim());
        if (isBullet && !inList) {
            result.push('<ul>');
            inList = true;
        } else if (!isBullet && inList) {
            result.push('</ul>');
            inList = false;
        }

        if (isBullet) {
            result.push(line.replace(/^- (.+)$/, '<li>$1</li>'));
        } else if (line.trim() === '') {
            result.push('<br>');
        } else {
            result.push(line);
        }
    }
    if (inList) result.push('</ul>');

    html = result.join('\n')
        // Clean up extra line breaks
        .replace(/\n(?!<)/g, ' ')
        .replace(/<br>\s*<br>/g, '<br>')
        .replace(/<\/h[34]>\s*/g, '</h4>')
        .replace(/<\/ul>\s*<br>/g, '</ul>')
        .replace(/<\/table>\s*<br>/g, '</table>');

    // Add clickable video links if videos were returned
    const videos = data.videos || [];
    if (videos.length > 0) {
        html += '<div class="chat-videos">';
        html += '<strong>Videos found:</strong><ul>';
        videos.slice(0, 5).forEach(v => {
            html += `<li><a href="transcripts/${v.slug}.html">${v.title}</a> <span class="meta">(${v.duration || formatDuration(v.duration_seconds)})</span></li>`;
        });
        if (videos.length > 5) {
            html += `<li><em>...and ${videos.length - 5} more</em></li>`;
        }
        html += '</ul></div>';
    }

    return html;
}

// System prompt for the AI assistant
const SYSTEM_PROMPT = `You are a helpful assistant for a YouTube learning library containing 1,708 indexed video transcripts.

FORMAT YOUR RESPONSES FOR A CHAT INTERFACE:
- Use **bold** for video titles and key terms
- Use bullet points (-) for lists
- Keep responses concise - 2-4 recommended videos max
- DO NOT use markdown tables
- Be concise and scannable`;

async function sendChatMessage() {
    const message = chatInput.value.trim();
    if (!message) return;

    // Add user message
    addChatMessage(message, 'user');
    chatInput.value = '';

    // Show loading
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'chat-message assistant loading';
    loadingDiv.innerHTML = '<p>Thinking...</p>';
    chatMessages.appendChild(loadingDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;

    // First, do a client-side search to get relevant videos
    const data = await loadLibraryData();
    const searchResults = data ? clientSideSearch(message, data.entries).slice(0, 10) : [];

    // Build context from search results
    let context = '';
    if (searchResults.length > 0) {
        context = '\n\nRelevant videos from the library:\n' + searchResults.map((r, i) =>
            `${i+1}. "${r.title}" (${formatDuration(r.duration_seconds)}, ${r.facets?.difficulty || 'intermediate'})\n   Topics: ${(r.facets?.topics || []).join(', ')}\n   Summary: ${(r.summary || []).slice(0, 2).join(' ')}`
        ).join('\n');
    }

    const userPrompt = `User query: ${message}${context}\n\nRecommend the most relevant videos and explain why they're useful.`;

    try {
        // Call the secure Worker endpoint (holds API key secretly)
        const response = await fetch(`${CONFIG.API_URL}/api/chat`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: 'gpt-oss:120b-cloud',
                messages: [
                    { role: 'system', content: SYSTEM_PROMPT },
                    { role: 'user', content: userPrompt }
                ],
                stream: false
            })
        });

        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }

        const result = await response.json();
        loadingDiv.remove();

        const aiResponse = result.message?.content || result.response || 'Sorry, I could not generate a response.';

        // Format response with video links
        const formattedData = {
            response: aiResponse,
            videos: searchResults
        };

        const msgDiv = document.createElement('div');
        msgDiv.className = 'chat-message assistant';
        msgDiv.innerHTML = formatChatResponse(formattedData);
        chatMessages.appendChild(msgDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;

    } catch (err) {
        loadingDiv.remove();
        console.error('Chat error:', err);

        // If API fails, at least show search results
        if (searchResults.length > 0) {
            const fallbackData = {
                response: `I found ${searchResults.length} videos matching your query:`,
                videos: searchResults
            };
            const msgDiv = document.createElement('div');
            msgDiv.className = 'chat-message assistant';
            msgDiv.innerHTML = formatChatResponse(fallbackData);
            chatMessages.appendChild(msgDiv);
        } else {
            addChatMessage('Could not connect to AI assistant. Please check your connection.', 'assistant');
        }
    }
}

chatBtn.addEventListener('click', sendChatMessage);
chatInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') sendChatMessage();
});

// === Search History ===
const HISTORY_KEY = 'library_search_history';
const MAX_HISTORY = 50;

function getHistory() {
    try {
        return JSON.parse(localStorage.getItem(HISTORY_KEY)) || [];
    } catch {
        return [];
    }
}

function saveHistory(history) {
    localStorage.setItem(HISTORY_KEY, JSON.stringify(history.slice(0, MAX_HISTORY)));
}

function addToHistory(query, type, resultCount = 0) {
    const history = getHistory();
    const entry = {
        query: query,
        type: type, // 'keyword' or 'ai'
        timestamp: new Date().toISOString(),
        resultCount: resultCount
    };
    // Remove duplicate if exists
    const filtered = history.filter(h => !(h.query === query && h.type === type));
    filtered.unshift(entry);
    saveHistory(filtered);
    renderHistory();
}

function formatHistoryTime(isoString) {
    const date = new Date(isoString);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    if (diffMins < 1) return 'just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    return date.toLocaleDateString();
}

function renderHistory() {
    const history = getHistory();
    const historyList = document.getElementById('history-list');

    if (history.length === 0) {
        historyList.innerHTML = '<p class="history-empty">No search history yet.</p>';
        return;
    }

    historyList.innerHTML = history.map((entry, idx) => `
        <div class="history-item" data-index="${idx}">
            <div class="history-item-main">
                <span class="history-type ${entry.type}">${entry.type === 'ai' ? 'AI' : 'Search'}</span>
                <span class="history-query">${entry.query}</span>
            </div>
            <div class="history-item-meta">
                <span class="history-time">${formatHistoryTime(entry.timestamp)}</span>
                ${entry.resultCount ? `<span class="history-results">${entry.resultCount} results</span>` : ''}
                <button class="history-rerun" data-query="${entry.query.replace(/"/g, '&quot;')}" data-type="${entry.type}">Run</button>
                <button class="history-delete" data-index="${idx}">×</button>
            </div>
        </div>
    `).join('');

    // Add click handlers
    historyList.querySelectorAll('.history-rerun').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const query = e.target.dataset.query;
            const type = e.target.dataset.type;
            if (type === 'ai') {
                chatInput.value = query;
                sendChatMessage();
            } else {
                searchInput.value = query;
                performSearch();
            }
        });
    });

    historyList.querySelectorAll('.history-delete').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const idx = parseInt(e.target.dataset.index);
            const history = getHistory();
            history.splice(idx, 1);
            saveHistory(history);
            renderHistory();
        });
    });
}

// History panel controls
const toggleHistoryBtn = document.getElementById('toggle-history');
const clearHistoryBtn = document.getElementById('clear-history');
const historyContent = document.getElementById('history-content');

toggleHistoryBtn.addEventListener('click', () => {
    const isHidden = historyContent.style.display === 'none';
    historyContent.style.display = isHidden ? 'block' : 'none';
    toggleHistoryBtn.textContent = isHidden ? 'Hide' : 'Show';
    if (isHidden) renderHistory();
});

clearHistoryBtn.addEventListener('click', () => {
    if (confirm('Clear all search history?')) {
        localStorage.removeItem(HISTORY_KEY);
        renderHistory();
    }
});

// Hook into existing search functions
const originalPerformSearch = performSearch;
performSearch = async function() {
    const query = searchInput.value.trim();
    await originalPerformSearch();
    if (query) {
        // Get result count from displayed results
        const resultsText = searchResults.querySelector('p')?.textContent || '';
        const match = resultsText.match(/Found (\d+)/);
        const count = match ? parseInt(match[1]) : 0;
        addToHistory(query, 'keyword', count);
    }
};

const originalSendChatMessage = sendChatMessage;
sendChatMessage = async function() {
    const query = chatInput.value.trim();
    if (query) {
        addToHistory(query, 'ai');
    }
    await originalSendChatMessage();
};

// Initial render
renderHistory();
</script>
{% endblock %}
